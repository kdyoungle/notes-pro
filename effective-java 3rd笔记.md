## Chapter 2: 创建和销毁对象
### Item 1: 考虑用静态工厂方法代替构造函数
### Item 2: 在面对多个构造函数时, 考虑使用构造器(builder)
### Item 3: 使用私有构造函数和枚举类型实现单例属性
### Item 4: 
### Item 9: try-with-resources优于try-finally
关闭类似文件流的操作时使用try-with-resources语句块, 使用该语句块时要求待关闭的对象是实现AutoCloseable接口的一个实例
## Chapter 3: 对象的通用方法
## Chapter 4: 类和接口
### Item 15: 尽量减少类和成员的可访问级别
### Item 16: 在public的类中使用访问器方法, 而不是通过public的字段
访问器方法包括但不限于 getter
### Item 17: 减少可变性
不可变对象的优点:
- 易于设计, 使用和实现, 不容易出错且更加安全
- 本质上是线程安全的, 不需要同步
缺点: 可能会有性能问题(重复的创建新对象, 不能对已有对象进行复用)

使类不可变, 需遵循的5个规则
- 不提供修改对象状态的方法
- 确保类不能被扩展
- 所有字段用final修饰
- 使所有字段私有
- 确保对任何可变组件的独占访问
### Item 18: 优先使用复合而不是继承
在同一个包中使用继承是安全的, 因为是由同一个程序员进行控制; 专门设计出来用于扩展且有详细的文档的类, 使用继承也是安全的.

decoration模式;
### Item 19: 使用继承时, 父类必须有良好的设计并且有对应文档 否则应该禁止使用
### Item 20: 接口由于抽象类
### Item 21: 为后代设计接口
确保接口设计后不会再进行更改, 虽然java8中提供了默认方法防止了向接口中添加方法时出现的实现类实现的问题, 但是并不能确保接口的默认实现运行在实现类上没有问题
### Item 22: 接口只用于定义类型
糟糕的应用: 使用接口定义常量
### Item 23: 类层次结构由于带标签的类
ards的那段代码改造
### Item 24: 支持使用静态成员类而不是非静态类(重要, 多看)
- 静态成员类
- 非静态成员类<br>
非静态成员类的每个实例都隐式的与外部类的实例相关联, 没有外部实例就不可能创建非静态成员类的实例<br>
常见用法是定义适配器
- 匿名类
- 局部类
## Chapter 5: 泛型
## Chapter 6: 枚举和注解
## Chapter 7: lambda表达式和流(Lambdas and Stream)
## Chapter 8: 方法(Methods)
