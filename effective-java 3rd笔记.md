## Chapter 2: 创建和销毁对象
### Item 1: 考虑用静态工厂方法代替构造函数
### Item 2: 在面对多个构造函数时, 考虑使用构造器(builder)
### Item 3: 使用私有构造函数和枚举类型实现单例属性
### Item 4: 
### Item 9: try-with-resources优于try-finally
关闭类似文件流的操作时使用try-with-resources语句块, 使用该语句块时要求待关闭的对象是实现AutoCloseable接口的一个实例
## Chapter 3: 对象的通用方法
## Chapter 4: 类和接口
### Item 15: 尽量减少类和成员的可访问级别
### Item 16: 在public的类中使用访问器方法, 而不是通过public的字段
访问器方法包括但不限于 getter
### Item 17: 减少可变性
不可变对象的优点:
- 易于设计, 使用和实现, 不容易出错且更加安全
- 本质上是线程安全的, 不需要同步
缺点: 可能会有性能问题(重复的创建新对象, 不能对已有对象进行复用)

使类不可变, 需遵循的5个规则
- 不提供修改对象状态的方法
- 确保类不能被扩展
- 所有字段用final修饰
- 使所有字段私有
- 确保对任何可变组件的独占访问
### Item 18: 优先使用复合而不是继承
在同一个包中使用继承是安全的, 因为是由同一个程序员进行控制; 专门设计出来用于扩展且有详细的文档的类, 使用继承也是安全的.

decoration模式;
### Item 19: 使用继承时, 父类必须有良好的设计并且有对应文档 否则应该禁止使用
### Item 20: 接口由于抽象类
### Item 21: 为后代设计接口
确保接口设计后不会再进行更改, 虽然java8中提供了默认方法防止了向接口中添加方法时出现的实现类实现的问题, 但是并不能确保接口的默认实现运行在实现类上没有问题
### Item 22: 接口只用于定义类型
糟糕的应用: 使用接口定义常量
### Item 23: 类层次结构由于带标签的类
ards的那段代码改造
### Item 24: 支持使用静态成员类而不是非静态类(重要, 多看)
- 静态成员类
- 非静态成员类<br>
非静态成员类的每个实例都隐式的与外部类的实例相关联, 没有外部实例就不可能创建非静态成员类的实例<br>
常见用法是定义适配器
- 匿名类
- 局部类
### Item 25: 源文件仅限有单个顶层类
一个写有多个class的.java文件中, 只能有一个public修饰的class<br>
永远不要将多个顶层类或者接口放在一个源文件中,以确保在编译时单个类不能用个多个定义<br>
如果必须要将多个顶层类放在一个文件中, 可以考虑使用静态成员类的方式
## Chapter 5: 泛型
### Item 26: 不要使用原始类型
### Item 27: 消除unchecked警告
### Item 28: list优于数组
### Item 29: 优先使用泛型
### Item 30: 优先使用泛型方法
### Item 31: 使用有界限定符增加API灵活性
数组与list的两个区别:
- 数组是协变的(子类元素可以放在父类类型的数组中), 泛型list是不变的(子类元素不能放在泛型为父类类型的list中)
- 数组是具体化的, 数组在运行时知道并强制执行他们的元素类型; 泛型时通过擦擦除来实现的, 其只在编译时执行类型约束, 在运行时丢弃或擦除类型信息, 擦除允许泛型和不使用泛型的遗留代码交互操作.(这个可以用反射来进行验证)
## Chapter 6: 枚举和注解
## Chapter 7: lambda表达式和流(Lambdas and Stream)
## Chapter 8: 方法(Methods)
